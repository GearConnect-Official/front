import { useState, useRef, useCallback, useMemo } from 'react';

interface ViewabilityConfig {
  minimumViewTime: number;
  itemVisiblePercentThreshold: number;
}

interface VisibilityTrackerState {
  visiblePosts: Set<string>;
  currentlyVisiblePost: string | null;
}

const useVisibilityTracker = (config?: Partial<ViewabilityConfig>) => {
  const [visibilityState, setVisibilityState] = useState<VisibilityTrackerState>({
    visiblePosts: new Set(),
    currentlyVisiblePost: null,
  });

  const finalConfig = useMemo(() => ({
    minimumViewTime: config?.minimumViewTime ?? 500,
    itemVisiblePercentThreshold: config?.itemVisiblePercentThreshold ?? 50,
  }), [config?.minimumViewTime, config?.itemVisiblePercentThreshold]);

  // Configuration pour FlatList
  const viewabilityConfig = useRef({
    minimumViewTime: finalConfig.minimumViewTime,
    itemVisiblePercentThreshold: finalConfig.itemVisiblePercentThreshold,
  }).current;

  // Callback pour gÃ©rer les changements de visibilitÃ©
  const onViewableItemsChanged = useCallback(
    ({ viewableItems, changed }: any) => {
      console.log('ðŸ“± Viewability changed:', {
        viewableItems: viewableItems.map((item: any) => item.key),
        changed: changed.map((item: any) => ({ key: item.key, isViewable: item.isViewable })),
      });

      const newVisiblePosts = new Set<string>();
      let newCurrentlyVisiblePost: string | null = null;

      // Traiter les Ã©lÃ©ments visibles
      viewableItems.forEach((item: any) => {
        if (item.isViewable) {
          newVisiblePosts.add(item.key);
          // Le premier Ã©lÃ©ment visible devient le post actuellement visible
          if (!newCurrentlyVisiblePost) {
            newCurrentlyVisiblePost = item.key;
          }
        }
      });

      // Mettre Ã  jour l'Ã©tat
      setVisibilityState(prevState => {
        const hasChanged = 
          prevState.visiblePosts.size !== newVisiblePosts.size ||
          prevState.currentlyVisiblePost !== newCurrentlyVisiblePost ||
          Array.from(prevState.visiblePosts).some(id => !newVisiblePosts.has(id));

        if (hasChanged) {
          console.log('ðŸ“± Visibility state updated:', {
            previousVisible: Array.from(prevState.visiblePosts),
            newVisible: Array.from(newVisiblePosts),
            previousCurrent: prevState.currentlyVisiblePost,
            newCurrent: newCurrentlyVisiblePost,
          });

          return {
            visiblePosts: newVisiblePosts,
            currentlyVisiblePost: newCurrentlyVisiblePost,
          };
        }

        return prevState;
      });
    },
    []
  );

  // RÃ©fÃ©rence pour le callback (requis par FlatList)
  const viewabilityConfigCallbackPairs = useRef([
    {
      viewabilityConfig,
      onViewableItemsChanged,
    },
  ]).current;

  // Fonctions utilitaires
  const isPostVisible = useCallback(
    (postId: string) => visibilityState.visiblePosts.has(postId),
    [visibilityState.visiblePosts]
  );

  const isPostCurrentlyVisible = useCallback(
    (postId: string) => visibilityState.currentlyVisiblePost === postId,
    [visibilityState.currentlyVisiblePost]
  );

  const getVisiblePostsCount = useCallback(
    () => visibilityState.visiblePosts.size,
    [visibilityState.visiblePosts]
  );

  return {
    // Ã‰tat
    visiblePosts: visibilityState.visiblePosts,
    currentlyVisiblePost: visibilityState.currentlyVisiblePost,
    
    // Configuration pour FlatList
    viewabilityConfigCallbackPairs,
    
    // Fonctions utilitaires
    isPostVisible,
    isPostCurrentlyVisible,
    getVisiblePostsCount,
  };
};

export default useVisibilityTracker; 